import { PDFDocument, PDFForm, PDFTextField, PDFCheckBox, PDFDropdown, PDFRadioGroup } from 'pdf-lib';
import { supabase } from '@/integrations/supabase/client';

export interface TemplateField {
  name: string;
  type: 'text' | 'checkbox' | 'dropdown' | 'radio';
}

export interface FieldMapping {
  pdfField: string;
  dataSource: string;
  dataPath?: string;
}

export interface CertificateTemplate {
  id: string;
  name: string;
  description: string | null;
  product_type: string | null;
  template_url: string;
  field_mappings: Record<string, string>;
  detected_fields: string[];
  is_default: boolean;
  active: boolean;
  created_by: string;
  created_at: string;
  updated_at: string;
}

// Available data sources for field mapping
export const DATA_SOURCES = [
  { id: 'serial_number', label: 'Serial Number', category: 'Product' },
  { id: 'wo_number', label: 'Work Order Number', category: 'Product' },
  { id: 'product_type', label: 'Product Type', category: 'Product' },
  { id: 'customer_name', label: 'Customer Name', category: 'Product' },
  { id: 'external_order_number', label: 'External Order Number', category: 'Product' },
  { id: 'certificate_date', label: 'Certificate Date', category: 'Meta' },
  { id: 'generated_by', label: 'Generated By', category: 'Meta' },
  { id: 'generated_date', label: 'Generated Date', category: 'Meta' },
  { id: 'measurement_1', label: 'Measurement 1', category: 'Measurements' },
  { id: 'measurement_2', label: 'Measurement 2', category: 'Measurements' },
  { id: 'measurement_3', label: 'Measurement 3', category: 'Measurements' },
  { id: 'measurement_4', label: 'Measurement 4', category: 'Measurements' },
  { id: 'measurement_5', label: 'Measurement 5', category: 'Measurements' },
  { id: 'batch_material_1', label: 'Batch Material 1', category: 'Materials' },
  { id: 'batch_material_2', label: 'Batch Material 2', category: 'Materials' },
  { id: 'batch_material_3', label: 'Batch Material 3', category: 'Materials' },
  { id: 'subassembly_sensor', label: 'Sensor Serial', category: 'Subassemblies' },
  { id: 'subassembly_mla', label: 'MLA Serial', category: 'Subassemblies' },
  { id: 'subassembly_hmi', label: 'HMI Serial', category: 'Subassemblies' },
  { id: 'subassembly_transmitter', label: 'Transmitter Serial', category: 'Subassemblies' },
];

/**
 * Detect form fields in a PDF template
 */
export async function detectPdfFields(pdfBytes: ArrayBuffer): Promise<TemplateField[]> {
  const pdfDoc = await PDFDocument.load(pdfBytes);
  const form = pdfDoc.getForm();
  const fields = form.getFields();
  
  const detectedFields: TemplateField[] = [];
  
  for (const field of fields) {
    const name = field.getName();
    let type: TemplateField['type'] = 'text';
    
    if (field instanceof PDFTextField) {
      type = 'text';
    } else if (field instanceof PDFCheckBox) {
      type = 'checkbox';
    } else if (field instanceof PDFDropdown) {
      type = 'dropdown';
    } else if (field instanceof PDFRadioGroup) {
      type = 'radio';
    }
    
    detectedFields.push({ name, type });
  }
  
  return detectedFields;
}

/**
 * Upload a PDF template to storage
 */
export async function uploadTemplate(
  file: File,
  name: string,
  description: string,
  productType: string | null
): Promise<{ templateId: string; detectedFields: TemplateField[] }> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Not authenticated');
  
  // Read file and detect fields
  const arrayBuffer = await file.arrayBuffer();
  const detectedFields = await detectPdfFields(arrayBuffer);
  
  // Upload to storage
  const fileName = `${Date.now()}-${file.name}`;
  const { error: uploadError } = await supabase.storage
    .from('certificate-templates')
    .upload(fileName, file, {
      contentType: 'application/pdf',
      upsert: false
    });
  
  if (uploadError) throw uploadError;
  
  // Create database record
  const { data: template, error: dbError } = await supabase
    .from('certificate_templates')
    .insert({
      name,
      description: description || null,
      product_type: productType || null,
      template_url: fileName,
      detected_fields: detectedFields.map(f => f.name),
      field_mappings: {},
      created_by: user.id
    })
    .select()
    .single();
  
  if (dbError) throw dbError;
  
  return {
    templateId: template.id,
    detectedFields
  };
}

/**
 * Update field mappings for a template
 */
export async function updateFieldMappings(
  templateId: string,
  mappings: Record<string, string>
): Promise<void> {
  const { error } = await supabase
    .from('certificate_templates')
    .update({ field_mappings: mappings })
    .eq('id', templateId);
  
  if (error) throw error;
}

/**
 * Set a template as default
 */
export async function setDefaultTemplate(templateId: string): Promise<void> {
  // First, unset all defaults
  await supabase
    .from('certificate_templates')
    .update({ is_default: false })
    .eq('is_default', true);
  
  // Set the new default
  const { error } = await supabase
    .from('certificate_templates')
    .update({ is_default: true })
    .eq('id', templateId);
  
  if (error) throw error;
}

/**
 * Get template for a product type or default
 */
export async function getTemplateForProduct(productType?: string): Promise<CertificateTemplate | null> {
  // First try product-specific template
  if (productType) {
    const { data: specific } = await supabase
      .from('certificate_templates')
      .select('*')
      .eq('product_type', productType)
      .eq('active', true)
      .single();
    
    if (specific) return specific as CertificateTemplate;
  }
  
  // Fall back to default template
  const { data: defaultTemplate } = await supabase
    .from('certificate_templates')
    .select('*')
    .eq('is_default', true)
    .eq('active', true)
    .single();
  
  return defaultTemplate as CertificateTemplate | null;
}

/**
 * Fill a PDF template with data
 */
export async function fillTemplate(
  template: CertificateTemplate,
  data: Record<string, any>
): Promise<Uint8Array> {
  // Download template from storage
  const { data: fileData, error: downloadError } = await supabase.storage
    .from('certificate-templates')
    .download(template.template_url);
  
  if (downloadError || !fileData) throw downloadError || new Error('Template not found');
  
  // Load PDF
  const pdfBytes = await fileData.arrayBuffer();
  const pdfDoc = await PDFDocument.load(pdfBytes);
  const form = pdfDoc.getForm();
  
  // Fill fields based on mappings
  const mappings = template.field_mappings as Record<string, string>;
  
  for (const [pdfFieldName, dataSourceId] of Object.entries(mappings)) {
    try {
      const field = form.getField(pdfFieldName);
      const value = resolveDataValue(dataSourceId, data);
      
      if (field instanceof PDFTextField && value !== undefined) {
        field.setText(String(value));
      } else if (field instanceof PDFCheckBox && value !== undefined) {
        if (value === true || value === 'true' || value === 'yes' || value === '1') {
          field.check();
        } else {
          field.uncheck();
        }
      }
    } catch (e) {
      console.warn(`Could not fill field ${pdfFieldName}:`, e);
    }
  }
  
  // Flatten the form to make fields non-editable
  form.flatten();
  
  // Save and return
  return await pdfDoc.save();
}

/**
 * Resolve a data source ID to actual value from certificate data
 */
function resolveDataValue(dataSourceId: string, data: Record<string, any>): any {
  // Direct mappings
  const directMappings: Record<string, string> = {
    'serial_number': 'serialNumber',
    'wo_number': 'woNumber',
    'product_type': 'productType',
    'customer_name': 'customerName',
    'external_order_number': 'externalOrderNumber',
    'certificate_date': 'certificateDate',
    'generated_by': 'generatedBy',
    'generated_date': 'generatedDate',
  };
  
  if (directMappings[dataSourceId]) {
    return data[directMappings[dataSourceId]];
  }
  
  // Measurement mappings (measurement_1, measurement_2, etc.)
  const measurementMatch = dataSourceId.match(/^measurement_(\d+)$/);
  if (measurementMatch && data.measurements) {
    const index = parseInt(measurementMatch[1]) - 1;
    const measurement = data.measurements[index];
    if (measurement) {
      return `${measurement.value} ${measurement.unit || ''}`.trim();
    }
  }
  
  // Batch material mappings
  const batchMatch = dataSourceId.match(/^batch_material_(\d+)$/);
  if (batchMatch && data.batchMaterials) {
    const index = parseInt(batchMatch[1]) - 1;
    const material = data.batchMaterials[index];
    if (material) {
      return `${material.materialType}: ${material.batchNumber}`;
    }
  }
  
  // Subassembly mappings
  const subassemblyMap: Record<string, string> = {
    'subassembly_sensor': 'SENSOR',
    'subassembly_mla': 'MLA',
    'subassembly_hmi': 'HMI',
    'subassembly_transmitter': 'TRANSMITTER',
  };
  
  if (subassemblyMap[dataSourceId] && data.subAssemblies) {
    const subType = subassemblyMap[dataSourceId];
    const sub = data.subAssemblies.find((s: any) => s.componentType === subType);
    if (sub) {
      return sub.serialNumber;
    }
  }
  
  return undefined;
}

/**
 * Preview a template with mock data
 */
export async function previewTemplate(templateId: string): Promise<Uint8Array> {
  const { data: template, error } = await supabase
    .from('certificate_templates')
    .select('*')
    .eq('id', templateId)
    .single();
  
  if (error || !template) throw error || new Error('Template not found');
  
  // Mock data for preview
  const mockData = {
    serialNumber: 'SENSOR-2024-00001',
    woNumber: 'WO-20241212-001',
    productType: 'SENSOR',
    customerName: 'Example Customer BV',
    externalOrderNumber: 'EXT-12345',
    certificateDate: new Date().toLocaleDateString(),
    generatedBy: 'System Preview',
    generatedDate: new Date().toISOString(),
    measurements: [
      { name: 'Frequency', value: '2.5', unit: 'MHz' },
      { name: 'Amplitude', value: '100', unit: 'mV' },
      { name: 'Temperature', value: '25', unit: 'Â°C' },
    ],
    batchMaterials: [
      { materialType: 'Epoxy', batchNumber: 'EPX-2024-001' },
      { materialType: 'Piezo', batchNumber: 'PZO-2024-042' },
    ],
    subAssemblies: [
      { componentType: 'SENSOR', serialNumber: 'SENSOR-2024-00001' },
      { componentType: 'MLA', serialNumber: 'MLA-2024-00015' },
    ],
  };
  
  return fillTemplate(template as CertificateTemplate, mockData);
}

/**
 * Delete a template
 */
export async function deleteTemplate(templateId: string): Promise<void> {
  // Get template to find storage path
  const { data: template } = await supabase
    .from('certificate_templates')
    .select('template_url')
    .eq('id', templateId)
    .single();
  
  if (template) {
    // Delete from storage
    await supabase.storage
      .from('certificate-templates')
      .remove([template.template_url]);
  }
  
  // Delete from database
  const { error } = await supabase
    .from('certificate_templates')
    .delete()
    .eq('id', templateId);
  
  if (error) throw error;
}

/**
 * Get all templates
 */
export async function getAllTemplates(): Promise<CertificateTemplate[]> {
  const { data, error } = await supabase
    .from('certificate_templates')
    .select('*')
    .order('created_at', { ascending: false });
  
  if (error) throw error;
  return (data || []) as CertificateTemplate[];
}
